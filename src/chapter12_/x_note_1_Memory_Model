    1.衡量一个服务性能的高低好坏，每秒事务处理能力（Transactions per second, TPS）是最重要的指标之一。

    JAVA内存模型
        1）主内存（Main Memory）和工作内存（Working Memory）
        Java内存模型规定了所有的变量均存储在主内存中，同时每条线程有自己的工作内存，线程的工作内存中保存着该线程使用到变量的主内存副本拷贝，线程对变量的所有
    操作（读取，赋值等）都必须在工作内存中进行，不能直接操作主内存中的变量。线程之间变量的传递必须通过主内存进行，而无法直接访问对方的工作内存。
        2）内存间交互操作
        java内存模型规定，虚拟机的实现必须保证以下8种操作必须是原子的，不可再分的。对于double和long而言，在某些平台上store，load，read，write操作允许有例外。
            1 > lock
            2 > unlock
            3 > read，作用于主内存，它把一个变量从主内存传递至线程的工作内存中，以便随后的load动作使用。
            4 > load，作用工作内存，它把read动作传递进的变量保存为线程工作内存的一个副本拷贝。
            5 > use
            6 > assign
            7 > store，作用于工作内存之中，它把工作内存中的变量传递至主内存之中，以便随后的write操作使用。
            8 > write
            如果要把一个变量从主内存中复制到工作内存中，那就要顺序地执行read和load操作，如果要把一个变量从工作内存复制到主内存中，那就要顺序地执行store和write
        操作。
            八种操作必须满足以下规则：
            1 > 不允许read，load和store，write操作单独出现；
            2 > 不允许一个线程丢弃它最近的assign操作，既变量在工作内存中改变之后必须同步至主内存之中；
            3 > 不允许线程无原因地（没有发生过任何assign操作）把变量从工作内存同步至主内存中；
            4 > 一个变量必须现在主内存中“诞生”；
            5 > 一个变量一个时刻只允许一条线程对其进行lock操作，但lock可以被一条线程反复执行，多次执行lock后，该线程要执行相同次的unlock操作后，变量才会被
            解锁；
            6 > 对一个变量执行lock操作，会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load操作；
            7 > 如果一个变量事先没有被lock锁定，那么是不允许先执行unlock操作的，也不允许执行一个被其他线程lock的变量；
            8 > 对一个变量执行unlock之前，必须先把此变量同步回主内存之中（执行store，write操作）。
