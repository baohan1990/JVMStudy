1.对象的创建
        虚拟机遇到一条new指令时，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个类的符号引用是否被虚拟机加载、解析、初始化过。
    如果没有，那么就必须先执行相应的类加载过程

        类加载检查通过以后，虚拟机将为新生对象分配内存，内存分配的方式有，指针碰撞（Bunmp the Pointer）和空闲列表（Free List）两种方式。具体采用哪种内存
    分配方式取决于java堆是否规整，而java堆是否规整取决于虚拟机所使用的垃圾回收算法，使用Serial，ParNew等带压缩功能的收集器时，系统采用指针碰撞分配内存，
    而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表

        并发情况下内存的划分，
        一）实际上虚拟机采用CAS（Compare and Swap）的方式保证更新操作的原子性；
        二）另一种是把内存的分配动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程缓冲（Thread Local Allocation Buffer）。
        只有TLAB用完时，需要同步锁定，虚拟机是否采用TLAB，可以通过-XX:+/-UserTLAB

        内存分配完成后，虚拟机要将分配到的内存空间全部初始化为零值

        对象头的设置

        执行<init>方法，按照程序员的意愿进行初始化

2.对象的布局
        在HotSpot虚拟机中，对象在内存中存储的布局可以分成三块区域：对象头（Header）/实例数据（Instance Data）/对其填充（Padding）

        第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、线程持有的锁、锁标志状态等，这部分数据长度在32位和64位虚拟机中分别是32bit，
    64bit。对象头定义的数据是与对象自身定义的数据无关的额外存储成本。对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个判断这个对象是
    那个类的实例。如果对象是一个Java数组，对象头中还有一块用于记录数组长度的数据

        实例数据存储各种类型的字段内容，无论是父类继承下来的，还是子类自身定义的。HotSpot虚拟机默认的分配的策略为longs/doubles,ints,shorts/chars,bites,boolean
    从分配策略来看，相同长度的字段总是被分配到一起，在满足这个前提条件的情况之下，父类定义的变量会出现在子类之前，
        如果CompactField参数值为true，那么子类较窄的变量可能会插入到父类变量的空隙之中

3.对象访问的定位
        使用句柄进行访问，reference存储对象的句柄地址，句柄中包含了类型数据和对象实例数据各自具体地址信息
        使用直接指针访问，reference存储对象的地址，对象中包含指向该对象类型数据的指针

        使用句柄访问的好处就是对象移动后，只需要修改句柄中实例数据的指针，而引用本身不需要修改
        直接访问的好处就是快，节省了一次指正定位的时间开销


